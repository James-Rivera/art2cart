<?php
/**
 * BackupManager Class for Art2Cart
 * Handles database backup and restore operations
 */

require_once __DIR__ . '/../config/db.php';

class BackupManager {
    private $db;
    private $backupDir;
    private $mysqldumpPath;
    
    public function __construct($backupDir = null) {
        $this->db = Database::getInstance();
        $this->backupDir = $backupDir ?: __DIR__ . '/../backups';
        $this->mysqldumpPath = $this->findMysqldump();
        
        // Ensure backup directory exists
        if (!is_dir($this->backupDir)) {
            mkdir($this->backupDir, 0755, true);
        }
    }
    
    /**
     * Find mysqldump executable path
     */
    private function findMysqldump() {
        // Common paths for mysqldump on Windows
        $commonPaths = [
            'mysqldump', // Check if it's in PATH first
        ];
        
        // Add WAMP paths dynamically
        $wampMysqlDir = 'C:\\wamp64\\bin\\mysql';
        if (is_dir($wampMysqlDir)) {
            $subdirs = glob($wampMysqlDir . '\\mysql*', GLOB_ONLYDIR);
            foreach ($subdirs as $subdir) {
                $commonPaths[] = $subdir . '\\bin\\mysqldump.exe';
            }
        }
        
        // Add other common paths
        $commonPaths = array_merge($commonPaths, [
            'C:\\xampp\\mysql\\bin\\mysqldump.exe',
            'C:\\mysql\\bin\\mysqldump.exe'
        ]);
        
        foreach ($commonPaths as $path) {
            if ($path === 'mysqldump') {
                // Test if mysqldump is in PATH
                $output = [];
                $returnCode = 0;
                exec('mysqldump --version 2>&1', $output, $returnCode);
                if ($returnCode === 0) {
                    return 'mysqldump';
                }
            } else {
                // Test if file exists at specific path
                if (file_exists($path)) {
                    return $path;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Create a database backup using mysqldump
     */
    public function createBackup($customFileName = null) {
        if (!function_exists('exec')) {
            throw new Exception('exec() function is not available');
        }
        
        if (!$this->mysqldumpPath) {
            throw new Exception('mysqldump executable not found');
        }
        
        $filename = $customFileName ?: 'art2cart_backup_' . date('Y-m-d_H-i-s') . '.sql';
        $backupFile = $this->backupDir . '/' . $filename;
        
        // Database configuration
        $dbConfig = [
            'host' => 'localhost',
            'username' => 'root',
            'password' => '',
            'database' => 'art2cart'
        ];
        
        // Build mysqldump command
        $baseCommand = ($this->mysqldumpPath === 'mysqldump') ? 'mysqldump' : '"' . $this->mysqldumpPath . '"';
        $command = $baseCommand . ' --host=' . $dbConfig['host'] . 
                   ' --user=' . $dbConfig['username'];
        
        if (!empty($dbConfig['password'])) {
            $command .= ' --password=' . $dbConfig['password'];
        }
        
        $command .= ' --single-transaction --routines --triggers --add-drop-table ' . 
                   $dbConfig['database'] . ' > "' . $backupFile . '" 2>&1';
        
        // Execute backup
        $output = [];
        $returnCode = 0;
        exec($command, $output, $returnCode);
        
        if ($returnCode === 0 && file_exists($backupFile) && filesize($backupFile) > 0) {
            return [
                'success' => true,
                'filename' => $filename,
                'filepath' => $backupFile,
                'size' => filesize($backupFile),
                'created' => date('Y-m-d H:i:s')
            ];
        } else {
            throw new Exception('Backup failed: ' . implode('\n', $output));
        }
    }
    
    /**
     * Create a PHP-based backup (alternative method)
     */
    public function createPHPBackup($customFileName = null) {
        $filename = $customFileName ?: 'art2cart_php_backup_' . date('Y-m-d_H-i-s') . '.sql';
        $backupFile = $this->backupDir . '/' . $filename;
        
        $conn = $this->db->getConnection();
        
        // Start building the SQL dump
        $dump = "-- Art2Cart Database Backup\n";
        $dump .= "-- Created on: " . date('Y-m-d H:i:s') . "\n";
        $dump .= "-- Generated by: PHP BackupManager\n\n";
        $dump .= "SET FOREIGN_KEY_CHECKS=0;\n\n";
        
        // Get all tables
        $stmt = $conn->query("SHOW TABLES");
        $tables = $stmt->fetchAll(PDO::FETCH_COLUMN);
        
        foreach ($tables as $table) {
            // Add DROP TABLE statement
            $dump .= "DROP TABLE IF EXISTS `$table`;\n";
            
            // Get CREATE TABLE statement
            $stmt = $conn->query("SHOW CREATE TABLE `$table`");
            $createTable = $stmt->fetch(PDO::FETCH_ASSOC);
            $dump .= $createTable['Create Table'] . ";\n\n";
            
            // Get table data
            $stmt = $conn->query("SELECT * FROM `$table`");
            $rows = $stmt->fetchAll(PDO::FETCH_ASSOC);
            
            if (!empty($rows)) {
                $columns = array_keys($rows[0]);
                $dump .= "INSERT INTO `$table` (`" . implode('`, `', $columns) . "`) VALUES\n";
                
                $values = [];
                foreach ($rows as $row) {
                    $rowValues = [];
                    foreach ($row as $value) {
                        if ($value === null) {
                            $rowValues[] = 'NULL';
                        } else {
                            $rowValues[] = "'" . addslashes($value) . "'";
                        }
                    }
                    $values[] = '(' . implode(', ', $rowValues) . ')';
                }
                
                $dump .= implode(",\n", $values) . ";\n\n";
            }
        }
        
        $dump .= "SET FOREIGN_KEY_CHECKS=1;\n";
        
        // Write to file
        if (file_put_contents($backupFile, $dump) === false) {
            throw new Exception('Failed to write backup file');
        }
        
        return [
            'success' => true,
            'filename' => $filename,
            'filepath' => $backupFile,
            'size' => filesize($backupFile),
            'created' => date('Y-m-d H:i:s'),
            'method' => 'PHP'
        ];
    }
    
    /**
     * List all available backups
     */
    public function listBackups() {
        if (!is_dir($this->backupDir)) {
            return [];
        }
        
        $backups = [];
        $files = glob($this->backupDir . '/*.sql');
        
        foreach ($files as $file) {
            $backups[] = [
                'filename' => basename($file),
                'filepath' => $file,
                'size' => filesize($file),
                'created' => date('Y-m-d H:i:s', filemtime($file))
            ];
        }
        
        // Sort by creation time (newest first)
        usort($backups, function($a, $b) {
            return filemtime($b['filepath']) - filemtime($a['filepath']);
        });
        
        return $backups;
    }
    
    /**
     * Delete a backup file
     */
    public function deleteBackup($filename) {
        $filepath = $this->backupDir . '/' . $filename;
        
        if (!file_exists($filepath)) {
            throw new Exception('Backup file not found');
        }
        
        if (!unlink($filepath)) {
            throw new Exception('Failed to delete backup file');
        }
        
        return true;
    }
      /**
     * Restore database from backup file with comprehensive verification
     * WARNING: This will replace all current data!
     */
    public function restoreBackup($filename) {
        if (!function_exists('exec')) {
            throw new Exception('exec() function is not available');
        }
        
        $filepath = $this->backupDir . '/' . $filename;
        
        if (!file_exists($filepath)) {
            throw new Exception('Backup file not found');
        }
        
        // Create a safety backup before restore
        $safetyBackup = $this->createBackup('safety_backup_before_restore_' . date('Y-m-d_H-i-s') . '.sql');
        
        // Store database state before restore for verification
        $preRestoreState = $this->getDatabaseState();
        
        // Find mysql executable (similar to mysqldump)
        $mysqlPath = str_replace('mysqldump', 'mysql', $this->mysqldumpPath);
        if ($this->mysqldumpPath === 'mysqldump') {
            $mysqlPath = 'mysql';
        }
        
        // Build mysql restore command
        $baseCommand = ($mysqlPath === 'mysql') ? 'mysql' : '"' . $mysqlPath . '"';
        $command = $baseCommand . ' --host=localhost --user=root art2cart < "' . $filepath . '" 2>&1';
        
        // Execute restore
        $output = [];
        $returnCode = 0;
        $startTime = microtime(true);
        exec($command, $output, $returnCode);
        $endTime = microtime(true);
        
        // Verify restore success
        $verification = $this->verifyRestore($filepath, $preRestoreState, $output, $returnCode);
        
        $result = [
            'success' => $verification['success'],
            'message' => $verification['message'],
            'restored_from' => $filename,
            'safety_backup' => $safetyBackup['filename'],
            'execution_time' => round($endTime - $startTime, 2),
            'verification_details' => $verification,
            'timestamp' => date('Y-m-d H:i:s')
        ];
        
        if (!$verification['success']) {
            throw new Exception($verification['message'] . "\n" . implode('\n', $output));
        }
        
        return $result;
    }
    
    /**
     * Comprehensive verification of restore operation
     */
    private function verifyRestore($backupFile, $preRestoreState, $output, $returnCode) {
        $verification = [
            'success' => false,
            'message' => '',
            'checks' => []
        ];
        
        try {
            // Check 1: Command execution return code
            $verification['checks']['return_code'] = [
                'name' => 'Command Return Code',
                'success' => $returnCode === 0,
                'message' => $returnCode === 0 ? 'Command executed successfully' : "Command failed with code: $returnCode",
                'value' => $returnCode
            ];
            
            // Check 2: Database connection after restore
            try {
                $conn = $this->db->getConnection();
                $verification['checks']['db_connection'] = [
                    'name' => 'Database Connection',
                    'success' => true,
                    'message' => 'Database connection successful after restore',
                    'value' => 'Connected'
                ];
            } catch (Exception $e) {
                $verification['checks']['db_connection'] = [
                    'name' => 'Database Connection',
                    'success' => false,
                    'message' => 'Database connection failed: ' . $e->getMessage(),
                    'value' => 'Failed'
                ];
                $verification['message'] = 'Database connection failed after restore';
                return $verification;
            }
            
            // Check 3: Database state after restore
            $postRestoreState = $this->getDatabaseState();
            $verification['checks']['table_count'] = [
                'name' => 'Table Count',
                'success' => $postRestoreState['table_count'] > 0,
                'message' => "Tables found: {$postRestoreState['table_count']}",
                'value' => $postRestoreState['table_count']
            ];
            
            // Check 4: Compare with backup file metadata
            $backupMetadata = $this->analyzeBackupFile($backupFile);
            if ($backupMetadata) {
                $tablesMatch = count(array_intersect($postRestoreState['tables'], $backupMetadata['tables'])) >= count($backupMetadata['tables']) * 0.9;
                $verification['checks']['table_structure'] = [
                    'name' => 'Table Structure Match',
                    'success' => $tablesMatch,
                    'message' => $tablesMatch ? 'Table structure matches backup' : 'Table structure mismatch detected',
                    'value' => [
                        'backup_tables' => count($backupMetadata['tables']),
                        'current_tables' => count($postRestoreState['tables']),
                        'matching_tables' => count(array_intersect($postRestoreState['tables'], $backupMetadata['tables']))
                    ]
                ];
            }
            
            // Check 5: Verify critical tables exist and have data
            $criticalTables = ['users', 'products', 'orders', 'categories']; // Adjust based on your schema
            $criticalTablesCheck = $this->verifyCriticalTables($criticalTables);
            $verification['checks']['critical_tables'] = $criticalTablesCheck;
            
            // Check 6: Test a simple query
            try {
                $stmt = $conn->query("SELECT COUNT(*) as total FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'art2cart'");
                $result = $stmt->fetch();
                $verification['checks']['query_test'] = [
                    'name' => 'Query Execution Test',
                    'success' => true,
                    'message' => 'Test query executed successfully',
                    'value' => $result['total'] . ' tables accessible'
                ];
            } catch (Exception $e) {
                $verification['checks']['query_test'] = [
                    'name' => 'Query Execution Test',
                    'success' => false,
                    'message' => 'Test query failed: ' . $e->getMessage(),
                    'value' => 'Failed'
                ];
            }
            
            // Check 7: Analyze command output for errors
            $hasErrors = false;
            $errorKeywords = ['ERROR', 'Failed', 'denied', 'unknown', 'syntax error'];
            foreach ($output as $line) {
                foreach ($errorKeywords as $keyword) {
                    if (stripos($line, $keyword) !== false) {
                        $hasErrors = true;
                        break 2;
                    }
                }
            }
            
            $verification['checks']['command_output'] = [
                'name' => 'Command Output Analysis',
                'success' => !$hasErrors,
                'message' => $hasErrors ? 'Errors detected in command output' : 'No errors in command output',
                'value' => count($output) . ' lines of output'
            ];
            
            // Overall success determination
            $successCount = 0;
            $totalChecks = 0;
            foreach ($verification['checks'] as $check) {
                $totalChecks++;
                if ($check['success']) {
                    $successCount++;
                }
            }
            
            $verification['success'] = $successCount >= $totalChecks * 0.8; // 80% of checks must pass
            $verification['message'] = $verification['success'] 
                ? "Restore verification passed ($successCount/$totalChecks checks)"
                : "Restore verification failed ($successCount/$totalChecks checks passed)";
                
            $verification['summary'] = [
                'passed_checks' => $successCount,
                'total_checks' => $totalChecks,
                'success_rate' => round(($successCount / $totalChecks) * 100, 1)
            ];
            
        } catch (Exception $e) {
            $verification['success'] = false;
            $verification['message'] = 'Verification process failed: ' . $e->getMessage();
        }
        
        return $verification;
    }
    
    /**
     * Get current database state for comparison
     */
    private function getDatabaseState() {
        $conn = $this->db->getConnection();
        
        // Get all tables
        $stmt = $conn->query("SHOW TABLES");
        $tables = $stmt->fetchAll(PDO::FETCH_COLUMN);
        
        // Get table counts
        $tableCounts = [];
        foreach ($tables as $table) {
            try {
                $stmt = $conn->query("SELECT COUNT(*) as count FROM `$table`");
                $result = $stmt->fetch();
                $tableCounts[$table] = $result['count'];
            } catch (Exception $e) {
                $tableCounts[$table] = 'Error: ' . $e->getMessage();
            }
        }
        
        return [
            'table_count' => count($tables),
            'tables' => $tables,
            'table_row_counts' => $tableCounts,
            'total_rows' => array_sum(array_filter($tableCounts, 'is_numeric'))
        ];
    }
    
    /**
     * Analyze backup file to extract metadata
     */
    private function analyzeBackupFile($backupFile) {
        if (!file_exists($backupFile)) {
            return false;
        }
        
        $content = file_get_contents($backupFile, false, null, 0, 10000); // Read first 10KB
        
        // Extract table names from CREATE TABLE statements
        preg_match_all('/CREATE TABLE.*?`([^`]+)`/i', $content, $matches);
        $tables = isset($matches[1]) ? $matches[1] : [];
        
        return [
            'tables' => $tables,
            'table_count' => count($tables),
            'file_size' => filesize($backupFile)
        ];
    }
    
    /**
     * Verify critical tables exist and are accessible
     */
    private function verifyCriticalTables($criticalTables) {
        $conn = $this->db->getConnection();
        $results = [
            'name' => 'Critical Tables Check',
            'success' => true,
            'message' => '',
            'details' => []
        ];
        
        foreach ($criticalTables as $table) {
            try {
                $stmt = $conn->query("SELECT COUNT(*) as count FROM `$table`");
                $result = $stmt->fetch();
                
                $results['details'][$table] = [
                    'exists' => true,
                    'accessible' => true,
                    'row_count' => $result['count']
                ];
            } catch (Exception $e) {
                $results['success'] = false;
                $results['details'][$table] = [
                    'exists' => false,
                    'accessible' => false,
                    'error' => $e->getMessage()
                ];
            }
        }
        
        $existingTables = count(array_filter($results['details'], function($detail) {
            return $detail['exists'];
        }));
        
        $results['message'] = "$existingTables/" . count($criticalTables) . " critical tables verified";
        
        return $results;
    }
    
    /**
     * Get backup directory path
     */
    public function getBackupDir() {
        return $this->backupDir;
    }
    
    /**
     * Check if mysqldump is available
     */
    public function isMysqldumpAvailable() {
        return $this->mysqldumpPath !== false;
    }
}
?>
